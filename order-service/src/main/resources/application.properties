# ===================================================================
# COMMON APPLICATION PROPERTIES
# ===================================================================

# Service Discovery
spring.application.name=order-service

# Server Port
server.port=${SERVER_PORT:8082}

# ===================================================================
# DATABASE CONFIGURATION (MongoDB)
# ===================================================================

spring.data.mongodb.uri=mongodb://${MONGODB_USERNAME:admin}:${MONGODB_PASSWORD:password}@${MONGODB_HOST:mongo}:${MONGODB_PORT:27017}/${MONGODB_DATABASE:orders}?authSource=admin


# ===================================================================
# KAFKA CONSUMER CONFIGURATION
# ===================================================================

# Kafka bootstrap servers
spring.kafka.bootstrap-servers=${KAFKA_HOST:localhost}:${KAFKA_PORT:9092}

# Name of the topic from which to consume user events
spring.kafka.topic.name=${SPRING_KAFKA_TOPIC_NAME:user-events-topic}

# Unique ID for the consumer group
spring.kafka.consumer.group-id=${SPRING_KAFKA_CONSUMER_GROUP_ID:order-service-group}

# Deserializer for the message key (String)
spring.kafka.consumer.key-deserializer=org.apache.kafka.common.serialization.StringDeserializer
# Deserializer for the message value (JSON to UserCreatedEvent)
spring.kafka.consumer.value-deserializer=org.springframework.kafka.support.serializer.JsonDeserializer

# When using JsonDeserializer, you must configure it to trust the package
# of the class you want to deserialize into. '*' is a wildcard for all packages,
# which is convenient for development but can be narrowed for production.
spring.kafka.consumer.properties.spring.json.trusted.packages=*

# Map the UserEvent class from user-service to order-service's UserEvent
spring.kafka.consumer.properties.spring.json.type.mapping=com.example.userservice.core.events.UserEvent:com.example.orderservice.core.events.UserEvent


# ===================================================================
# CACHING CONFIGURATION (Redis)
# ===================================================================

# Tell Spring Boot to use Redis for caching
spring.cache.type=redis

# Connection details for Redis
spring.data.redis.host=${SPRING_DATA_REDIS_HOST:localhost}
spring.data.redis.port=${SPRING_DATA_REDIS_PORT:6379}

# Default Time-To-Live (TTL) for all cache entries created by this service
spring.cache.redis.time-to-live=${SPRING_CACHE_REDIS_TIME_TO_LIVE:10m}

# Prefix for this service to avoid key collisions in Redis
spring.cache.redis.key-prefix=${SPRING_CACHE_REDIS_KEY_PREFIX:order-service::}

# ===================================================================
# JWT SECURITY CONFIGURATION
# ===================================================================
# JWT secret - will be overridden by environment variables in production
application.security.jwt.secret-key=${APPLICATION_SECURITY_JWT_SECRET_KEY:DefaultSecretKeyForLocalDevelopmentOnly}
# Token validity in milliseconds. This should match the expiration in user-service.
# 86400000 ms = 24 hours.
application.security.jwt.expiration=86400000
