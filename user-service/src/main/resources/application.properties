# ===================================================================
# COMMON APPLICATION PROPERTIES
# ===================================================================

# Service Discovery
spring.application.name=user-service

# Server Port
# Each microservice will run on a different port to avoid conflicts.
server.port=8081


# ===================================================================
# DATABASE CONFIGURATION (PostgreSQL)
# ===================================================================

# The 'postgres' hostname refers to the service name in docker-compose.yml.
# Docker's internal DNS will resolve this to the correct container IP.
spring.datasource.url=jdbc:postgresql://postgres:5432/interview_project_db
spring.datasource.username=user
spring.datasource.password=password
spring.datasource.driver-class-name=org.postgresql.Driver

# ===================================================================
# JPA & HIBERNATE CONFIGURATION
# ===================================================================

# Strategy for creating or updating the database schema.
# 'update': updates the schema if it has changed, creates it if it doesn't exist.
# 'validate': validates the schema, makes no changes to the database.
# 'create': creates the schema, destroying previous data.
# 'create-drop': creates the schema and destroys it when the session factory is closed.
# 'none': does nothing.
spring.jpa.hibernate.ddl-auto=update

# Show SQL statements in the logs. Useful for debugging.
spring.jpa.show-sql=true

# Hibernate dialect for PostgreSQL
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect


# ===================================================================
# KAFKA PRODUCER CONFIGURATION
# ===================================================================

# Name of the topic to which user events will be published
spring.kafka.topic.name=user-events-topic

# Serializer for the message key (user ID as a String)
spring.kafka.producer.key-serializer=org.apache.kafka.common.serialization.StringSerializer
# Serializer for the message value (UserCreatedEvent object as JSON)
spring.kafka.producer.value-serializer=org.springframework.kafka.support.serializer.JsonSerializer


# ===================================================================
# CACHING CONFIGURATION (Redis)
# ===================================================================

# Tell Spring Boot to use Redis for caching
spring.cache.type=redis

# Connection details for Redis. These are typically set via environment variables in docker-compose.yml
# but we provide defaults here.
spring.data.redis.host=localhost
spring.data.redis.port=6379

# Default Time-To-Live (TTL) for all cache entries created by this service.
# Here, we set it to 10 minutes. After this time, the entry is automatically evicted.
spring.cache.redis.time-to-live=600000

# It is a best practice to use a prefix for all keys related to an application
# to avoid key collisions if the same Redis instance is used by multiple apps.
spring.cache.redis.key-prefix=user-service::


# ===================================================================
# LOGGING
# ===================================================================

logging.level.org.hibernate.SQL=DEBUG
logging.level.org.hibernate.type.descriptor.sql.BasicBinder=TRACE

# ===================================================================
# JWT SECURITY CONFIGURATION
# ===================================================================
# IMPORTANT: In a real production environment, this secret key MUST be externalized
# and should NOT be in version control. Use environment variables or a secret manager.
# This key should be a long, random, base64-encoded string.
app.jwt.secret=DefaultSecretKeyNeedsToBeChangedAndMadeMuchLongerForProduction
# Token validity in milliseconds. 86400000 ms = 24 hours.
app.jwt.expiration-in-ms=86400000
